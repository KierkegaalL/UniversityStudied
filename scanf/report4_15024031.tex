%==========================================================================
%Template File
%   Copyright (C) 2006-2009                                
%           by Shinya Watanabe(sin@csse.muroran-it.ac.jp) 
%==========================================================================
\documentclass[a4j,titlepage]{jarticle}
\usepackage{sty/programing_report}
\usepackage{cases}
\usepackage{sty/jquote}
\usepackage{sty/eclbkbox}
\usepackage{sty/itembkbx}
\usepackage{sty/emathC}
\usepackage{graphicx}
\begin{document}

%--------------------
%以下に実験レポートのタイトル,自分のクラス名，学籍番号，氏名，提出日を書く．
%--------------------

%%\title{レポートタイトル}を記述する．
\title{コンピュータ知能学演習 レポート}

%%\author{クラス名}{学籍番号}{氏名}を記述する．
\author{15024031}{奥　龍司}

%%\date{提出する年月日}を記述する．
\date{2016年8月1日}
\maketitle

%--------------------
%以下から本文を開始する．
%--------------------


\section{プログラムソース}
　以下に今回の課題で作成したプログラムのソースを記述する。
\begin{breakitembox}[l]{選択法} \small
\begin{verbatim}
/********************************************
名前： Selection.c
機能： 選択法で、降順でソートする
入力及び出力： ランダムな数値を出力
作者： 15024031 奥　龍司
特記事項：特になし
********************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


#define N 100 // データ数


void generateData(int *data);         //データを生成する関数
void selectionSort(int *data);        //選択法でソートする関数
void viewData(int *data);             //配列 data の内容を表示する関数
void swap(int *data, int i, int j);   //data[i] と data[j] の内容を交換する関数


int main(void) {

  int data[N];
  
  
  generateData(data);
  printf("selectionSort 使用前:\n");
  viewData(data);                    // ソート前のデータを表示
  

  printf("\nselectionSort 使用後:\n");
  selectionSort(data);               // 選択法の実行
  viewData(data);                    // ソート後のデータを表示
  
  
 return 0;
}



void selectionSort(int *data) {

  int idx, i, j;
  for (i = 0; i <= N-1; i++)
    {
      idx = i;                       // 最小または最大の要素の位置 idx を初期化
      for (j = i+1; j < N; j++       // i+1 番目以降の最小または最大のデータを探す
	{                               
	  if (data[j] > data[idx])    　 // 昇順・降順に応じて条件を適切に設定すること
	    {
	      idx = j;                 　// i+1 番目以降で最小または最大のデータの番号を idx に代入
	    }
	}
      swap(data, i, idx);            // i 番目の要素と最大または最小の要素とを入れ替える
    }

}



void swap(int *data, int i, int j){  // data[i] と data[j] の内容を交換する(各自作成すること)

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}




void viewData(int *data){        // 配列 data の内容を表示する(各自作成すること)

  int i=0;

  for (i = 0; i < N; i++){
    printf("%d ",data[i]);
  }

  printf("\n");

}



void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }

}
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{挿入法} \small
\begin{verbatim}
/********************************************
名前： Insertion.c 
機能： 
入力及び出力： 
作者： 15024031 奥　龍司
特記事項：番兵を用いた場合
********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 100 // データ数

void generateData(int *data);            //データを生成する関数
void insertionSort(int *data);           //挿入法でソートする関数
void viewData(int *data);                //配列 data の内容を表示する関数
void swap(int *data, int i, int j);      //data[i] と data[j] の内容を交換する関数


int main(void) {
  
  int data[N];
  
  generateData(data);
  data[0] = -10 * N; // 挿入法の場合は「番兵」を用いるのが一般的

  
  /* 以下,選択法の場合と同様に,ソート前のデータを表示,挿入法の実行,
     ソート後のデータを表示,と進む.各自作成すること. */

  printf("InsertionSort 使用前:\n");
  viewData(data);                        // ソート前のデータを表示
  

  printf("\nInsertionSort 使用後:\n");
  insertionSort(data);                   // 挿入法の実行
  viewData(data);                        // ソート後のデータを表示
  
  return 0;
}



void insertionSort(int *data) {
  
  int idx, i;

  for (i = 1; i <= N-1; i++)
    {
      idx = i;
      while (data[idx-1] > data[idx]) { // idx 番目とその 1 つ前のデータを比較
	swap(data, idx-1,idx);                       // 1 つ前のデータの方が大きければ入れ替える
	idx--;
      }
    }
  
}



void swap(int *data, int i, int j)       // data[i] と data[j] の内容を交換する(各自作成すること)
{

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}




void viewData(int *data){                // 配列 data の内容を表示する(各自作成すること)

  int i=0;

  for (i = 0; i < N; i++)
    {
      printf("%d ",data[i]);
    }

  printf("\n");

}



void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }

}




/********************************************
名前： Insertion.c 
機能： 
入力及び出力： 
作者： 15024031 奥　龍司
特記事項：番兵を用いない場合
********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 100 // データ数

void generateData(int *data);            //データを生成する関数
void insertionSort(int *data);           //挿入法でソートする関数
void viewData(int *data);                //配列 data の内容を表示する関数
void swap(int *data, int i, int j);      //data[i] と data[j] の内容を交換する関数


int main(void) {
  
  int data[N];
  
  generateData(data);

  
  /* 以下,選択法の場合と同様に,ソート前のデータを表示,挿入法の実行,
     ソート後のデータを表示,と進む.各自作成すること. */

  printf("InsertionSort 使用前:\n");
  viewData(data);                        // ソート前のデータを表示
  

  printf("\nInsertionSort 使用後:\n");
  insertionSort(data);                   // 挿入法の実行
  viewData(data);                        // ソート後のデータを表示
  
  return 0;
}



void insertionSort(int *data) {
  
  int idx, i;

  for (i = 1; i <= N-1; i++)
    {
      idx = i;
      while (data[idx-1] > data[idx]) { // idx 番目とその 1 つ前のデータを比較
	swap(data, idx-1,idx);                       // 1 つ前のデータの方が大きければ入れ替える
	idx--;
      }
    }
  
}



void swap(int *data, int i, int j)       // data[i] と data[j] の内容を交換する(各自作成すること)
{

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}




void viewData(int *data){                // 配列 data の内容を表示する(各自作成すること)

  int i=0;

  for (i = 0; i < N; i++)
    {
      printf("%d ",data[i]);
    }

  printf("\n");

}



void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }

}
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{バブルソート} \small
\begin{verbatim}
/********************************************
名前： Bubble.c
機能： 
入力及び出力： 
作者： 15024031 奥　龍司
特記事項：特になし
********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 100 // データ数

void generateData(int *data);            //データを生成する関数
void bubbleSort(int *data);             //バブルソートでソートする関数
void viewData(int *data);                //配列 data の内容を表示する関数
void swap(int *data, int i, int j);      //data[i] と data[j] の内容を交換する関数


int main(void) {
  
  int data[N];
  
  generateData(data);
  data[0] = -10 * N; // 挿入法の場合は「番兵」を用いるのが一般的

  
  /* 以下,選択法の場合と同様に,ソート前のデータを表示,挿入法の実行,
     ソート後のデータを表示,と進む.各自作成すること. */

  printf("InsertionSort 使用前:\n");
  viewData(data);                        // ソート前のデータを表示
  

  printf("\nInsertionSort 使用後:\n");
  bubbleSort(data);                      // バブルソートの実行
  viewData(data);                        // ソート後のデータを表示
  
  return 0;
}


void bubbleSort(int *data) {
  
  int i, j;
  
  for (i = N-1; i > 0; i--)             // 配列の先頭に到達するまで繰り返す
    { 
    
    for (j = 0; j < i; j++)            // 配列の先頭からどこまで調べるか?
      {             
	if (data[j] > data[j+1])       // 隣接するデータの比較.昇順・降順の違いに注意
	  {
	    swap(data, j, j+1);
	  }
    }
    
  }
   
}





void swap(int *data, int i, int j){       // data[i] と data[j] の内容を交換する(各自作成すること)

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}


void viewData(int *data)  {              // 配列 data の内容を表示する(各自作成すること)
  
  int i=0;
  
  for (i = 0; i < N; i++)
    {
      printf("%d ",data[i]);
    }
  
  printf("\n");

}


void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }

}
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{マージソート} \small
\begin{verbatim}
/********************************************
名前： Merge.c
機能： 
入力及び出力： 
作者： 15024031 奥　龍司
特記事項：特になし
********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 100 // データ数

void generateData(int *data);            //データを生成する関数
void merge(int *tmp, int left, int right);
void mergeSort(int *data, int left, int right);
void viewData(int *data);                //配列 data の内容を表示する関数
void swap(int *data, int i, int j);      //data[i] と data[j] の内容を交換する関数

int tmp[N];


int main(void) {
  
  int data[N];
  int tmp[N];                            // マージソートではデータ配列と同程度の作業領域が必要

  
  generateData(data);
  printf("mergeSort 使用前:\n");
  viewData(data);                        // ソート前のデータを表示
  

  printf("\nmergeSort 使用後:\n");
  mergeSort(data,0,N-1);                 // マージソートの実行
  viewData(data);                        // ソート後のデータを表示
  

  return 0;
}


/* 配列 data の left 番目から right 番目の範囲でマージソートを行う */
void merge(int *data, int left, int right) {

  int i;

  for (i=left; i<=right; i++){
    tmp[i] = data[i];
  }

}


void mergeSort(int *data, int left, int right) {

  int i, j, k, half;


  if (left < right)                          // 範囲内に 2 個以上のデータがあるときのみ処理する
    {                   
      half = (left + right) / 2;             // 範囲内のほぼ中央の位置を取得
      mergeSort(data, left, half);           // データの左半分について再帰
      mergeSort(data, half+1, right);        // データの右半分について再帰
      merge(data, left, right);              // left から right の範囲内でデータを作業領域にコピー (各自作成すること)
      
      i = left; j = half + 1;
      
      for(k = left; k <= right; k        //left から right の範囲でマージ操作を行う
	{
	  if(i > half)                   //データの左半分はすべて処理済みの場合
	    {
	      data[k] = tmp[j++];        //右半分の先頭の要素を取得
	    }
	  else if(j > right)             //データの右半分はすべて処理済みの場合
	    {
	      data[k] = tmp[i++];        //左半分の先頭の要素を取得
	    }
	  else if (tmp[i] < tmp[j])      //どちらでもない場合は小さい方から戻してマージする
	    {
	      data[k] = tmp[i++];
	    }
	  else
	    {
	      data[k] = tmp[j++];
	    }
	  
	}
    }    
}


void swap(int *data, int i, int j){       // data[i] と data[j] の内容を交換する(各自作成すること)

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}


void viewData(int *data)  {              // 配列 data の内容を表示する(各自作成すること)
  
  int i=0;
  
  for (i = 0; i < N; i++)
    {
      printf("%d ",data[i]);
    }
  
  printf("\n");

}


void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }
}

\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{クイックソート} \small
\begin{verbatim}
/********************************************
名前： Quick.c
機能： 
入力及び出力： 
作者： 15024031 奥　龍司
特記事項：特になし
********************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 100 // データ数

void generateData(int *data);            //データを生成する関数
void quickSort(int *data, int left, int right);
void viewData(int *data);                //配列 data の内容を表示する関数
void swap(int *data, int i, int j);      //data[i] と data[j] の内容を交換する関数


int main(void) {
  
  int data[N];
  int left;
  int right;

  
  generateData(data);
  printf("quickSort 使用前:\n");
  viewData(data);                        // ソート前のデータを表示
  

  printf("\nquickSort 使用後:\n");
  quickSort(data,0,N-1);          // クイックソートの実行
  viewData(data);                        // ソート後のデータを表示
  
  return 0;
}




void quickSort(int *data, int left, int right) {
  
  
  int k;
  
  
  if (left < right) {
    
    k = partition(data, left, right);  // data を分割する枢軸の位置を求める
    
    quickSort(data, left, k-1);        // 値が枢軸より小さい要素への再帰
    quickSort(data, k+1, right);       // 値が枢軸より大きい要素への再帰
  }
}



int partition(int *data, int left, int right) {
  
  
  int piv, i, j;
  

  piv = data[left];                       // 指定範囲の左端を枢軸とする
  i = left;
  j = right + 1;
  

  while (1) 
    {
      while (i < right && data[++i] < piv); // 枢軸より大きい要素の番号 i を取得
      while (data[--j] > piv);              // 枢軸より小さい要素の番号 j を取得
      if (i >= j)
	{ 
	  break; 
	}                                   // i が j 以上になったら終了
      swap(data, i, j);                     // data[i] と data[j] の入れ替え
    }
  swap(data, left, j);                    // 枢軸を正しい位置に移動
  
  return j;                               // 枢軸の場所を返す
}

    



void swap(int *data, int i, int j){       // data[i] と data[j] の内容を交換する(各自作成すること)

  int tmp ;

  tmp = data[i] ;
  data[i] = data[j];
  data[j] = tmp;
    
}




void viewData(int *data)  {              // 配列 data の内容を表示する(各自作成すること)
  
  int i=0;
  
  for (i = 0; i < N; i++)
    {
      printf("%d ",data[i]);
    }
  
  printf("\n");

}



void generateData(int *data) {

  int i; 
  
  /* -5N+1 から 5N の範囲で乱数 N 個を生成し,配列 data に格納する */
  srand((unsigned)time(NULL));           // 現在時刻から疑似乱数の種を生成する
  
  for (i = 0; i < N; i++)
    {
      data[i] = (rand() % (10* N)) + (-5 * N - 1);
    }

}
\end{verbatim}
\end{breakitembox}

\section{プログラムの実行}
プログラムの実行結果を以下に記す。
\begin{breakitembox}[l]{選択法} \small
\begin{verbatim}
j15024031@ubuntu:~/computer_ensyu$ gcc -o Selection Selection.c
j15024031@ubuntu:~/computer_ensyu$ ./Selection
selectionSort 使用前:
221 21 107 119 -397 -87 12 252 431 -153 -2 -82 -316 -477 -478 -20 -293 -166 196 -159 
-176 196 367 -367 142 144 242 -33 -107 211 -207 -33 -267 401 -61 189 167 -196 294 99 
-496 146 -129 41 170 -106 -477 -270 229 -428 424 -445 269 292 41 264 290 -216 85 36 
-152 379 -144 434 281 297 476 -51 -46 272 -99 -40 -81 -375 -498 -58 21 -122 -475 103 
-49 451 -489 74 -404 53 -161 387 -309 425 -76 40 -343 282 -24 -209 432 -47 241 -113 

selectionSort 使用後:
476 451 434 432 431 425 424 401 387 379 367 297 294 292 290 282 281 272 269 264 252 
242 241 229 221 211 196 196 189 170 167 146 144 142 119 107 103 99 85 74 53 41 41 40
36 21 21 12 -2 -20 -24 -33 -33 -40 -46 -47 -49 -51 -58 -61 -76 -81 -82 -87 -99 -106 
-107 -113 -122 -129 -144 -152 -153 -159 -161 -166 -176 -196 -207 -209 -216 -267 -270
-293 -309 -316 -343 -367 -375 -397 -404 -428 -445 -475 -477 -477 -478 -489 -496 -498 
j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{挿入法(番兵を用いた場合)} \small
\begin{verbatim}

j15024031@ubuntu:~/computer_ensyu$ gcc -o Insertion Insertion.c
j15024031@ubuntu:~/computer_ensyu$ ./Insertion
InsertionSort 使用前:
-1000 -361 -332 378 -342 156 -347 -120 -350 477 -42 -254 -498 14 187 -497 -391 -376 
34 483 -395 239 217 -107 -214 -267 -96 300 366 265 -193 17 405 -24 248 -84 -15 402 
-350 136 -268 461 -265 -265 -24 424 -260 438 -451 -373 423 7 367 493 -246 -346 79 
-489 456 298 277 116 -183 -465 -55 -434 305 431 -178 -192 420 55 -230 -344 292 248 
-67 -467 -461 -17 -339 -185 -156 -119 162 451 37 -258 463 346 -458 -407 -37 212 -371
409 -369 -213 -307 -46 

InsertionSort 使用後:
-1000 -498 -497 -489 -467 -465 -461 -458 -451 -434 -407 -395 -391 -376 -373 -371 -369 
-361 -350 -350 -347 -346 -344 -342 -339 -332 -307 -268 -267 -265 -265 -260 -258 -254
-246 -230 -214 -213 -193 -192 -185 -183 -178 -156 -120 -119 -107 -96 -84 -67 -55 -46 
-42 -37 -24 -24 -17 -15 7 14 17 34 37 55 79 116 136 156 162 187 212 217 239 248 248 
265 277 292 298 300 305 346 366 367 378 402 405 409 420 423 424 431 438 451 456 461 
463 477 483 493 
j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{挿入法(番兵を用いなかった場合)} \small
\begin{verbatim}

j15024031@ubuntu:~/computer_ensyu$ gcc -o Insertion Insertion.c
j15024031@ubuntu:~/computer_ensyu$ ./Insertion
InsertionSort 使用前:
-1000 -263 -357 -325 -24 18 177 433 276 -139 14 -330 27 -410 404 -169 -212 430 35 -121 151 57 401 -375 258 -361 25 -251 170 -380 -104 54 -265 -172 492 52 430 114 322 -311 -309 -5 379 22 472 183 335 -393 343 20 -267 412 318 -22 -43 105 162 416 -431 -237 11 307 -296 488 -237 202 -169 165 -265 -113 -178 168 -332 -378 393 282 25 393 229 38 425 174 382 252 -324 -183 76 -134 495 385 -202 -195 -171 -190 -190 -412 186 417 -47 54 

InsertionSort 使用後:
-1000 -431 -412 -410 -393 -380 -378 -375 -361 -357 -332 -330 -325 -324 -311 -309 -296 -267 -265 -265 -263 -251 -237 -237 -212 -202 -195 -190 -190 -183 -178 -172 -171 -169 -169 -139 -134 -121 -113 -104 -47 -43 -24 -22 -5 11 14 18 20 22 25 25 27 35 38 52 54 54 57 76 105 114 151 162 165 168 170 174 177 183 186 202 229 252 258 276 282 307 318 322 335 343 379 382 385 393 393 401 404 412 416 417 425 430 430 433 472 488 492 495 

j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{バブルソート} \small
\begin{verbatim}
j15024031@ubuntu:~/computer_ensyu$ gcc -o Bubble Bubble.c
j15024031@ubuntu:~/computer_ensyu$ ./Bubble
BubbleSort 使用前:
-1000 398 -235 -247 -58 401 112 259 -475 -495 234 -92 -438 220 -358 179 -283 94 -431 
276 404 154 -497 -273 -375 241 330 -43 -63 492 225 496 -257 491 -250 186 -255 -284 
-54 123 74 33 -467 138 -246 -324 -182 324 -377 -112 102 -120 -105 458 108 373 201 291 
-168 -9 -363 -442 340 -119 -97 -408 -431 -499 161 368 126 88 -97 -488 -273 -490 41 46
336 -483 -212 291 -102 -464 250 -141 411 304 4 -256 -204 142 155 -362 -476 -89 83 -406 
-86 97 

BubbleSort 使用後:
-1000 -499 -497 -495 -490 -488 -483 -476 -475 -467 -464 -442 -438 -431 -431 -408 -406 
-377 -375 -363 -362 -358 -324 -284 -283 -273 -273 -257 -256 -255 -250 -247 -246 -235 
-212 -204 -182 -168 -141 -120 -119 -112 -105 -102 -97 -97 -92 -89 -86 -63 -58 -54 -43 
-9 4 33 41 46 74 83 88 94 97 102 108 112 123 126 138 142 154 155 161 179 186 201 220 
225 234 241 250 259 276 291 291 304 324 330 336 340 368 373 398 401 404 411 458 491 
492 496 
j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{マージソート} \small
\begin{verbatim}
j15024031@ubuntu:~/computer_ensyu$ gcc -o Merge Merge.c
j15024031@ubuntu:~/computer_ensyu$ ./Merge
mergeSort 使用前:
-473 -226 140 451 469 228 -368 271 471 145 -207 313 228 -344 227 -434 -254 121 118 53
-35 456 115 252 114 388 343 -251 -490 -151 -150 -462 476 -156 490 447 -427 -377 -429 
-455 269 -135 359 -1 22 87 418 -378 62 389 -472 -120 -301 144 -15 -334 385 -171 -84 
-252 179 -381 -213 157 -36 130 457 38 -393 -471 436 377 247 296 229 123 237 -499 -402
-200 391 -373 181 -57 -376 -333 110 -490 349 -473 -240 29 -352 400 39 465 32 349 357 
140 

mergeSort 使用後:
-499 -490 -490 -473 -473 -472 -471 -462 -455 -434 -429 -427 -402 -393 -381 -378 -377 
-376 -373 -368 -352 -344 -334 -333 -301 -254 -252 -251 -240 -226 -213 -207 -200 -171 
-156 -151 -150 -135 -120 -84 -57 -36 -35 -15 -1 22 29 32 38 39 53 62 87 110 114 115 
118 121 123 130 140 140 144 145 157 179 181 227 228 228 229 237 247 252 269 271 296 
313 343 349 349 357 359 377 385 388 389 391 400 418 436 447 451 456 457 465 469 471 
476 490 
j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}

\begin{breakitembox}[l]{クイックソート} \small
\begin{verbatim}
j15024031@ubuntu:~/computer_ensyu$ gcc -o Quick Quick.c
j15024031@ubuntu:~/computer_ensyu$ ./Quick
quickSort 使用前:
322 -490 306 196 -455 265 -220 203 153 -303 243 -421 67 367 461 301 202 296 106 322 
-7 -224 184 242 -14 -432 168 81 154 105 270 -22 468 78 -325 -134 -156 -44 -77 -149 
-493 19 -69 427 -113 245 230 -57 42 189 -234 -111 466 451 -368 -46 -128 -347 -112 -473
-389 -341 6 -420 238 -465 300 -64 344 -276 288 352 244 72 -367 -15 -182 -284 429 -287 
406 48 455 -275 0 -412 180 373 95 -79 -247 207 82 261 -359 173 -351 -206 -390 494 

quickSort 使用後:
-493 -490 -473 -465 -455 -432 -421 -420 -412 -390 -389 -368 -367 -359 -351 -347 -341 
-325 -303 -287 -284 -276 -275 -247 -234 -224 -220 -206 -182 -156 -149 -134 -128 -113 
-112 -111 -79 -77 -69 -64 -57 -46 -44 -22 -15 -14 -7 0 6 19 42 48 67 72 78 81 82 95 
105 106 153 154 168 173 180 184 189 196 202 203 207 230 238 242 243 244 245 261 265 
270 288 296 300 301 306 322 322 344 352 367 373 406 427 429 451 455 461 466 468 494 
j15024031@ubuntu:~/computer_ensyu$ 
\end{verbatim}
\end{breakitembox}


%\section{グラフ}
%\vspace{5cm}
%\begin{figure}[h]
 % \includegraphics[width=24cm,bb=0 140 2000 387]{kyumenzu.png}
%  \hspace*{8cm}
 % \vspace*{-1cm}
  %\includegraphics[width=24cm,bb=0 0 5000 387]{kyuumenzu2.png}
%\end{figure}


\section{実行時間}
以下に、上記のプログラムの実行した際のデータ数100個および 1000個、1万個、10万個について調べた結果を示す
\\
\\
\begin{tabular}{|l|l|l|l|l|}
\hline
 & 100 & 1000 & 1万 & 10万 \\
\hline
選択法 & 0m0.006s & 0m0.033s & 0m0.176s & 0m14.706s \\
挿入法 & 0m0.006s & 0m0.033s & 0m0.214s & 0m20.170s \\
バブルソート & 0m0.006s & 0m0.043s & 0m0.453s & 0m41.933s
 \\
マージソート & 0m0.006s & 0m0.011s & 0m0.021s & 0m0.129s \\
クイックソート & 0m0.006s & 0m0.010s & 0m0.020s & 0m0.120s \\
\hline
\end{tabular}

\section{考察}
5つのソートで4種類のデータ数を調べた結果、クイックソートとマージソートがデータ数が多いほど最も早いソートとなった。逆にデータ数の小さいと、どのソート方法でも結果は大差変わらなかった。これはデータ数が小さい時は並び替える効率の良し悪しはあまり影響されないためどれも大差変わらないが、多くなれば多くなるほど影響が出てくることが見て取れる。よってマージソートやクイックソートは効率が良いソート方法であるということが推測される。
 

%------------
%以下，参考文献に関する記述
%------------
%\begin{thebibliography}{9}
%%\small{
%%\bibitem{minamoto} やさしく学べる　C言語入門[第2版]-基礎から数値計算入門まで-　皆本晃弥 著
%}
%%\end{thebibliography}
\end{document}
